
-- 11/11/2019 notes

SELECT *
FROM member;
-- create table accnt
CREATE TABLE account (
acc_num         VARCHAR(7) PRIMARY KEY      ,
acc_opendate    DATE DEFAULT SYSDATE        ,
acc_balance     NUMBER(10,2)                 ,
acc_limit       NUMBER (10,2) DEFAULT 5000 NOT NULL ,
mem_num         NUMBER   NOT null                           ,
CONSTRAINT account_mem_num_fk foreign KEY(mem_num)    references member
);


-- alter table  gives ability to change structure of table
-- 3 diff types add, modify, and drop


-- MODIFY
ALTER TABLE ACCOUNT
MODIFY ACC_BALANCE DEFAULT 0 NOT NULL;


-- ADD
ALTER TABLE ACCOUNT
ADD CONSTRAINT ACCOUNT_BAL_LIMIT_CK CHECK (ACC_BALANCE <= ACC_LIMIT);


 -- ADDED NEW COLUMN TO TABLE
ALTER TABLE ACCOUNT
ADD ACC_CLOSEDATE DATE DEFAULT SYSDATE;


SELECT *
FROM ACCOUNT;


-- INSERT DATA INTO ACCOUNT TABLE
INSERT INTO ACCOUNT VALUES ('1234567','15-OCT-19',0,4000,101,NULL);
INSERT INTO ACCOUNT VALUES ('2345678', DEFAULT, 0, 5000, 102, NULL);

INSERT INTO ACCOUNT (ACC_NUM, MEM_NUM) VALUES ('3456789',101);

-- COMMIT OR FINALIZE TABLE CHANGES
COMMIT;


-- CHANGE A ROW WITH UPDATE
UPDATE ACCOUNT
SET ACC_BALANCE = 100
WHERE ACC_NUM = '1234567';



UPDATE ACCOUNT
SET ACC_BALANCE = ACC_BALANCE + 500,
    ACC_LIMIT = 6000
WHERE ACC_NUM = '1234567';



UPDATE ACCOUNT
SET ACC_LIMIT = ACC_LIMIT + 1000
WHERE MEM_NUM = 101;



-- DELETE ROW

DELETE FROM ACCOUNT
WHERE ACC_NUM = '2345678';


-- ROLLBACK    IS THE COUNTERPART TO COMMIT WILL UNDO ALL CHANGES TO LAST BEFORE TIME BEFORE COMMIT

ROLLBACK;


-- VIEWS
CREATE VIEW PRODAVERAGES AS
SELECT P_CODE, P_DESCRIPT, P_PRICE, AVGPRICE, P_PRICE - AVGPRICE AS DIFF, PRODUCT.V_CODE, V_NAME
FROM PRODUCT  LEFT JOIN (SELECT VENDOR.V_CODE,  V_NAME, Avg(P_PRICE) AS AVGPRICE
                        FROM VENDOR  LEFT JOIN PRODUCT ON VENDOR.V_CODE = PRODUCT.V_CODE
                        GROUP BY VENDOR.V_CODE, V_NAME)VENDAVGS ON PRODUCT.V_CODE = VENDAVGS.V_CODE
ORDER BY PRODUCT.V_CODE, P_CODE;


SELECT P_CODE, P_DESCRIPT, V_NAME, DIFF
FROM PRODAVERAGES
WHERE DIFF > 0;

-- USE VIEWS TO IMPROVE SECURITY , HIDE COMPLEXITY OF UNDERLYING QUERY


SELECT * FROM USER_VIEWS;


SELECT * FROM ALL_VIEWS WHERE VIEW_NAME = 'USER_TABLES';



-- TO REMOVE VIEW
DROP VIEW PRODAVERAGES;

-- CANT USE VIEWS FOR ANY ASSIGNMENTS IN THIS COURSE UNLESS EXPLICITLY STATED

-- 11/13/2019 notes

-- can rename tables by using rename command
RENAME MEMBER TO OLDMEMBER;


-- SEQUENCES IS A STRUCTRE THAT ALLOWS YOU TO GET AUTO NUMBER CAPABILITY LIKE IN MICROSOFT ACCESS, ESPECIALLY WEHN USING SURROGATE KEYS
-- IN ORACLE A SWQUENCE IS NOT A DATA TYPE, OR EVEN ASSICOIATED WITH A ATTRRIBUTE OR A PARTICULAR TABLE , IN ORACLE IT JUST GENERATES NUMBERS
-- CAN HAVE SEQUENCE START WITH ANY NUMBER YOU WANT TO
SELECT * FROM VENDOR;

SELECT Max(V_CODE) FROM VENDOR;  -- FIGURE OUT LARGEST VCODE


CREATE SEQUENCE VEND_V_CODE_SEQ
START WITH 25596
INCREMENT BY 1 -- BY DEFAULT WILL INCREMENT BY 1
NOCACHE;

SELECT * FROM USER_SEQUENCES;

INSERT INTO VENDOR VALUES
(VEND_V_CODE_SEQ.NEXTVAL, 'ABC COMPANY', 'SMITH', '615','111-1212','TN','N');


SELECT * FROM VENDOR;
SELECT * FROM PRODUCT;

INSERT INTO PRODUCT VALUES
('123', 'SAW BLADE', SYSDATE, 10, 5, 10.99,0, VEND_V_CODE_SEQ.CURRVAL, 0) ;


ROLLBACK;          -- ROLLBACK DOESNT NOT ROLLBACK SEQUENCES

-- HOW TO GET RID OF SEQUENCES   , USE DROP SEQUENCE
DROP SEQUENCE VEND_V_CODE_SEQ;



-- PROCEDURAL SQL  PL/SQL START

-- simple block
BEGIN
  Dbms_OutPut.PUT_LINE ( 'Hellow, World!');
END;
/   -- signals the end of program

-- VARIABLE EXAMPLE

DECLARE
  MYNUM NUMBER(1,0);           -- precision, scale

BEGIN
  MYNUM := 3;
  MYNUM := MYNUM + 2;          -- there is no += in pl/sql have to type whole thing out
  Dbms_Output.PUT_LINE('MYNUM has the value: ' || MYNUM);
END;
/

/*
  NUMBER(3,2) 9.99
  NUMBER(5,1) 9999.9
  NUMBER (,1) .9
*/

DECLARE
 MYNUM1 NUMBER(1);
 MYNUM2 NUMBER(4,1);
 TOTAL  NUMBER(6,1);

BEGIN
  MYNUM1 := 5;
  MYNUM2 := 20.1;
  TOTAL := MYNUM1 * MYNUM2;

IF MYNUM1 = 5 THEN
    Dbms_Output.PUT_LINE( ' this is the mynum1 = 5 line');
    MYNUM1 := MYNUM1 + 1;
    Dbms_Output.PUT_LINE( ' Changed to :  '  || MYNUM1);
END IF;

IF TOTAL < 100 THEN
    Dbms_Output.PUT_LINE( ' Total less than 100');
ELSE
    Dbms_Output.PUT_LINE( ' Total equal or greater to 100');

END IF;
Dbms_Output.PUT_LINE( ' Total = ' || TOTAL);

END;
/


DECLARE                          -- CAN INTIALIZE VARIABLES IN DECLARE CLASUE
    MYNUM1 NUMBER(1) := 5;
    MYNUM2 NUMBER(4,1) := 120.1;
    TOTAL NUMBER(6,1) ;

BEGIN
    TOTAL := MYNUM1 + MYNUM2;
    IF TOTAL < 100 THEN
      Dbms_Output.PUT_LINE( ' LESS THAN 100');
      Dbms_Output.PUT_LINE( ' TOTAL is small ');
    ELSIF TOTAL BETWEEN 100 AND 1000 THEN
      Dbms_Output.PUT_LINE( 'TOTAL is medium small');
    ELSIF TOTAL BETWEEN 1000 AND 5000 THEN
      Dbms_Output.PUT_LINE( ' TOTAL is medium LARGE');
    ELSIF  TOTAL BETWEEN 5000 AND 9999 THEN
      Dbms_Output.PUT_LINE( 'TOTAL getting BIG');
    ELSE
      Dbms_Output.PUT_LINE( 'TOTAL IS BIG!!!');
    END IF;
END;
/


/*


    ELSE IF       ELSE {
                          IF {
                                }
                        }
    ELSEIF        ELSE IF {
                            }
ELSEIF IN P/SQL WILL ONLY RUN FIRST INSTANCE OF ELSEIF WHEN TRUE ,
IT WONT RUN THE OTHER ONES
*/







